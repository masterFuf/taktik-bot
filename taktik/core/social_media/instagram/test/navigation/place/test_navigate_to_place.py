#!/usr/bin/env python3
"""
Script de test pour valider la navigation vers l'onglet "Places" et l'interaction avec les posts d'un lieu Instagram.

Usage:
    python test_navigate_to_place.py <place_name> [max_posts]

Exemple:
    python test_navigate_to_place.py "Lausanne, Switzerland" 10
    python test_navigate_to_place.py "Paris" 15

Ce test effectue :
1. Recherche d'un lieu dans la barre de recherche Instagram
2. Navigation vers l'onglet "Places"
3. S√©lection du premier r√©sultat de lieu
4. Navigation dans les posts du lieu (Top/R√©cents)
5. Interaction avec les posts disponibles
"""

import sys
import argparse
import time
from pathlib import Path

# Ajouter le r√©pertoire racine au PYTHONPATH
root_dir = Path(__file__).resolve().parents[7]
sys.path.insert(0, str(root_dir))

from loguru import logger
from taktik.core.social_media.instagram.actions.core.device_manager import DeviceManager
from taktik.core.social_media.instagram.workflows.management.session import SessionManager
from taktik.core.social_media.instagram.actions.navigation.navigation_manager import NavigationManager
from taktik.core.social_media.instagram.views.place_view import PlaceView
from taktik.core.social_media.instagram.ui.detectors.scroll_end import ScrollEndDetector


class NavigateToPlaceTest:
    """Test de navigation vers l'onglet Places et interaction avec les posts d'un lieu."""
    
    def __init__(self):
        self.device_manager = None
        self.session_manager = None
        self.navigation_manager = None
        self.place_view = None
        self.scroll_detector = None
        
    def setup(self, place_name: str):
        """
        Initialise les composants n√©cessaires pour le test.
        
        Args:
            place_name: Nom du lieu √† rechercher
        """
        logger.info(f"üß™ [TEST] Initialisation du test de navigation vers place pour '{place_name}'")
        
        # Initialiser le gestionnaire de p√©riph√©rique
        self.device_manager = DeviceManager()
        self.device_manager.connect()
        logger.success(f"‚úÖ Device connect√©: {self.device_manager.device_id}")
        
        # Initialiser le gestionnaire de session
        test_config = {
            'session_settings': {
                'session_duration_minutes': 30,
                'max_likes': 10,
                'max_follows': 5
            }
        }
        self.session_manager = SessionManager(test_config)
        logger.success("‚úÖ SessionManager initialis√©")
        
        # Initialiser le gestionnaire de navigation
        self.navigation_manager = NavigationManager(self.device_manager.device)
        logger.success("‚úÖ NavigationManager initialis√©")
        
        # Initialiser la vue des lieux
        self.place_view = PlaceView(self.device_manager.device)
        logger.success("‚úÖ PlaceView initialis√©")
        
        # Initialiser le d√©tecteur de fin de scroll
        self.scroll_detector = ScrollEndDetector(device=self.device_manager.device)
        logger.success("‚úÖ ScrollEndDetector initialis√©")
        
    def test_navigate_to_search(self) -> bool:
        """
        Teste la navigation vers la barre de recherche.
        
        Returns:
            bool: True si la navigation r√©ussit, False sinon
        """
        logger.info("üîç [TEST] Test de navigation vers la barre de recherche")
        
        try:
            # Naviguer vers la page de recherche
            if self.navigation_manager.navigate_to_search():
                logger.success("‚úÖ Navigation vers la recherche r√©ussie")
                time.sleep(2)  # Attendre le chargement
                return True
            else:
                logger.error("‚ùå Impossible de naviguer vers la recherche")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la navigation vers la recherche: {e}")
            return False
    
    def test_search_place(self, place_name: str) -> bool:
        """
        Teste la recherche d'un lieu et la navigation vers l'onglet Places.
        
        Args:
            place_name: Nom du lieu √† rechercher
            
        Returns:
            bool: True si la recherche r√©ussit, False sinon
        """
        logger.info(f"üèôÔ∏è [TEST] Test de recherche de lieu: '{place_name}'")
        
        try:
            # Effectuer la recherche
            if self.navigation_manager.search_place(place_name):
                logger.success(f"‚úÖ Recherche de lieu '{place_name}' r√©ussie")
                time.sleep(2)  # Attendre les r√©sultats
                
                # Cliquer sur la suggestion de recherche (premier r√©sultat avec loupe)
                if self.navigation_manager.click_search_suggestion(place_name):
                    logger.success("‚úÖ Clic sur la suggestion de recherche r√©ussi")
                    time.sleep(2)  # Attendre le chargement de la page avec les onglets
                    
                    # Naviguer vers l'onglet Places
                    if self.navigation_manager.navigate_to_places_tab():
                        logger.success("‚úÖ Navigation vers l'onglet Places r√©ussie")
                        time.sleep(2)  # Attendre le chargement
                        return True
                    else:
                        logger.error("‚ùå Impossible de naviguer vers l'onglet Places")
                        return False
                else:
                    logger.error("‚ùå Impossible de cliquer sur la suggestion de recherche")
                    return False
            else:
                logger.error(f"‚ùå Impossible de rechercher le lieu '{place_name}'")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la recherche de lieu: {e}")
            return False
    
    def test_select_first_place_result(self) -> bool:
        """
        Teste la s√©lection du premier r√©sultat de lieu.
        
        Returns:
            bool: True si la s√©lection r√©ussit, False sinon
        """
        logger.info("üéØ [TEST] Test de s√©lection du premier r√©sultat de lieu")
        
        try:
            if self.navigation_manager.select_first_place_result():
                logger.success("‚úÖ S√©lection du premier r√©sultat de lieu r√©ussie")
                time.sleep(3)  # Attendre le chargement de la page du lieu
                return True
            else:
                logger.error("‚ùå Impossible de s√©lectionner le premier r√©sultat")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la s√©lection du r√©sultat: {e}")
            return False
    
    def test_navigate_to_top_posts(self) -> bool:
        """
        Teste la navigation vers les posts "Top" du lieu.
        
        Returns:
            bool: True si la navigation r√©ussit, False sinon
        """
        logger.info("üîù [TEST] Test de navigation vers les posts Top")
        
        try:
            if self.place_view.switch_to_top_posts():
                logger.success("‚úÖ Navigation vers les posts Top r√©ussie")
                time.sleep(2)  # Attendre le chargement
                return True
            else:
                logger.error("‚ùå Impossible de naviguer vers les posts Top")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la navigation vers Top: {e}")
            return False
    
    def test_navigate_to_recent_posts(self) -> bool:
        """
        Teste la navigation vers les posts "Recent" du lieu.
        
        Returns:
            bool: True si la navigation r√©ussit, False sinon
        """
        logger.info("üìÖ [TEST] Test de navigation vers les posts Recent")
        
        try:
            if self.place_view.switch_to_recent_posts():
                logger.success("‚úÖ Navigation vers les posts Recent r√©ussie")
                time.sleep(2)  # Attendre le chargement
                return True
            else:
                logger.error("‚ùå Impossible de naviguer vers les posts Recent")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la navigation vers Recent: {e}")
            return False
    
    def test_detect_posts_in_place(self, max_posts: int = 10) -> int:
        """
        Teste la d√©tection des posts dans la page du lieu.
        
        Args:
            max_posts: Nombre maximum de posts √† d√©tecter
            
        Returns:
            int: Nombre de posts d√©tect√©s
        """
        logger.info(f"üé¨ [TEST] Test de d√©tection des posts (max: {max_posts})")
        
        try:
            posts_detected = 0
            posts_list = []
            
            def post_callback(post_element, post_info) -> bool:
                nonlocal posts_detected
                posts_detected += 1
                posts_list.append(post_info)
                
                if posts_detected % 3 == 0:
                    logger.info(f"üé¨ Post {posts_detected}: {post_info.get('caption', 'Sans l√©gende')[:50]}...")
                
                return posts_detected < max_posts
            
            processed_count = self.place_view.iterate_over_posts(
                iteration_callback=post_callback
            )
            
            logger.info(f"üìä [R√âSULTAT] {posts_detected} posts d√©tect√©s sur {processed_count} trait√©s")
            
            if posts_detected > 0:
                logger.info("üé¨ Premiers posts:")
                for i, post in enumerate(posts_list[:3]):
                    logger.info(f"  - Post {i+1}: {post.get('caption', 'Sans l√©gende')[:30]}...")
            
            return posts_detected
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la d√©tection des posts: {e}")
            return 0
    
    def test_scroll_place_posts(self) -> bool:
        """
        Teste le scroll dans les posts du lieu.
        
        Returns:
            bool: True si le scroll r√©ussit, False sinon
        """
        logger.info("üìú [TEST] Test du scroll dans les posts du lieu")
        
        try:
            self.scroll_detector.reset()
            
            posts_before_scroll = self.place_view.count_visible_posts()
            logger.info(f"üìä Posts visibles avant scroll: {posts_before_scroll}")
            
            # Effectuer un scroll
            self.place_view.scroll_down()
            time.sleep(2)  # Attendre le chargement
            
            posts_after_scroll = self.place_view.count_visible_posts()
            logger.info(f"üìä Posts visibles apr√®s scroll: {posts_after_scroll}")
            
            if posts_after_scroll > posts_before_scroll:
                logger.success("‚úÖ Scroll r√©ussi - nouveaux posts d√©tect√©s")
                return True
            else:
                logger.warning("‚ö†Ô∏è Scroll effectu√© mais pas de nouveaux posts d√©tect√©s")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du scroll: {e}")
            return False
    
    def cleanup(self):
        """
        Nettoie les ressources apr√®s le test.
        """
        logger.info("üßπ [TEST] Nettoyage des ressources")
        
        try:
            if self.device_manager:
                # Utiliser la m√©thode correcte pour nettoyer le device
                if hasattr(self.device_manager, 'cleanup'):
                    self.device_manager.cleanup()
                    logger.info("‚úÖ Device nettoy√© avec cleanup()")
                elif hasattr(self.device_manager, 'disconnect'):
                    self.device_manager.disconnect()
                    logger.info("‚úÖ Device d√©connect√© avec disconnect()")
                else:
                    logger.warning("‚ö†Ô∏è Aucune m√©thode de nettoyage trouv√©e pour le device")
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du nettoyage: {e}")


def main():
    """Point d'entr√©e principal du script de test."""
    parser = argparse.ArgumentParser(
        description="Test de navigation vers l'onglet Places et interaction avec les posts d'un lieu"
    )
    parser.add_argument("place_name", help="Nom du lieu √† rechercher")
    parser.add_argument("max_posts", type=int, nargs="?", default=10, 
                        help="Nombre maximum de posts √† d√©tecter (d√©faut: 10)")
    parser.add_argument("--verbose", "-v", action="store_true", 
                        help="Mode verbeux pour plus de d√©tails")
    
    args = parser.parse_args()
    
    if args.verbose:
        logger.add(sys.stdout, level="DEBUG")
    
    place_name = args.place_name
    max_posts = args.max_posts
    
    logger.info(f"üöÄ [TEST] D√©marrage du test de navigation place pour '{place_name}' (max: {max_posts})")
    
    test_runner = NavigateToPlaceTest()
    
    try:
        # Initialisation
        test_runner.setup(place_name)
        
        # Tests s√©quentiels
        tests = [
            ("Navigation vers recherche", lambda: test_runner.test_navigate_to_search()),
            ("Recherche de lieu", lambda: test_runner.test_search_place(place_name)),
            ("S√©lection du lieu", lambda: test_runner.test_select_first_place_result()),
            ("Navigation vers Top", lambda: test_runner.test_navigate_to_top_posts()),
            ("D√©tection posts Top", lambda: test_runner.test_detect_posts_in_place(max_posts) > 0),
            ("Scroll dans les posts", lambda: test_runner.test_scroll_place_posts()),
            ("Navigation vers Recent", lambda: test_runner.test_navigate_to_recent_posts()),
            ("D√©tection posts Recent", lambda: test_runner.test_detect_posts_in_place(5) > 0),
        ]
        
        results = []
        for test_name, test_func in tests:
            logger.info(f"üß™ [TEST] Ex√©cution: {test_name}")
            try:
                result = test_func()
                results.append((test_name, result))
                if result:
                    logger.success(f"‚úÖ {test_name}: R√âUSSI")
                else:
                    logger.error(f"‚ùå {test_name}: √âCHEC")
            except Exception as e:
                logger.error(f"‚ùå {test_name}: ERREUR - {e}")
                results.append((test_name, False))
        
        # R√©sum√© final
        success_count = sum(1 for _, result in results if result)
        total_count = len(results)
        
        logger.info(f"üìä [R√âSUM√â] {success_count}/{total_count} tests r√©ussis")
        
        if success_count == total_count:
            logger.success("‚úÖ [TEST] Test de navigation place termin√© avec succ√®s")
        else:
            logger.error(f"‚ùå [TEST] Test termin√© avec {total_count - success_count} √©checs")
            
    except Exception as e:
        logger.error(f"‚ùå Erreur critique lors du test: {e}")
    finally:
        test_runner.cleanup()


if __name__ == "__main__":
    main()
